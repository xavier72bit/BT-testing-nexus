# interaction

## 这里是做什么的

interaction 模块是本项目的核心，它主要负责定时驱动各类任务，完成与外部系统的自动化交互。这些任务是项目能够持续运行、收集数据和执行自动化命令的关键。

为了满足项目对任务速率的灵活控制，我们没有采用 Spring Boot 默认的 @Scheduled 注解，而是自行实现了动态定时任务管理机制。这套机制允许我们在不重启应用的情况下，实时调整任务的执行频率。

这种机制尤其适用于：
* 数据采集：以可控的速率搜集区块链网络的数据信息，如区块快照、交易池状态等。
* 自动化命令：动态控制诸如“以什么样的速率自动生成交易”这类命令的执行频率。


## 动态定时任务管理机制

本项目使用了一套自定义的定时任务管理机制，以实现 Spring Boot `@Scheduled` 注解无法满足的**动态调整任务执行速率**的需求。

### 一、核心背景

Spring Boot 提供的 `@Scheduled` 注解功能强大，但其任务执行间隔通常在应用启动时就已固定，无法在运行时动态修改。这不满足我们对某些任务（如：数据采集）的灵活控制需求。为此，我们设计了这套基于 Spring IOC 和数据库配置的动态调度系统。

### 二、工作原理

我们的核心理念是：**将任务的调度与具体的业务逻辑解耦，并允许在任务执行时动态刷新下一次的执行间隔。**

1.  **任务注册**：当 Spring IOC 容器启动并创建 `DynamicConfigScheduler` 实例时，它的 `@PostConstruct` 方法会被触发。在这个方法中，我们手动将一个定时任务注册到 Spring 的 `TaskScheduler` 中。
2.  **动态触发**：这个任务并不是一个简单的固定频率任务，而是一个**动态触发器**（`DynamicTrigger`）。每次任务执行完毕后，这个触发器都会查询数据库，获取最新的配置值，以此来决定下一次任务的启动时间。
3.  **循环执行**：这个过程会持续循环，从而实现了在不重启应用的情况下，根据数据库配置实时调整任务执行频率的功能。

### 三、核心类及其职责

本项目将定时任务管理分为三个核心部分，职责清晰，易于扩展：


* `DynamicConfigScheduler` (调度器)：这是**动态任务的父类**，定义了所有动态调度的行为。它负责在应用启动时将任务注册到 `TaskScheduler`。通过 `DynamicTrigger` 动态获取和更新任务间隔，**如果你需要创建一个可以动态调整频率的任务，只需继承这个类即可。**

* `ScheduledTaskToRun` (任务接口)：这是一个简单的接口，定义了具体任务的执行方法`execute()`。它解耦了调度器和任务的业务逻辑。

* `client`包：这里的类实现了与区块链网络中的各个不同的组件进行交互，主要负责发送http请求。

### 四、DynamicConfigScheduler类之间的协作关系

`DynamicConfigScheduler` 及其子类通过以下两样东西紧密协作，共同完成动态调度任务：

1.  `ConfigKey`：子类需要提供一个 `ConfigKey`，用于指定在数据库 `Config` 表中对应的配置项。`DynamicConfigScheduler` 会根据这个 `ConfigKey` 获取任务的下一次执行间隔。
2.  `ScheduledTaskToRun` 实例：子类需要提供一个 `ScheduledTaskToRun` 的实例，这个实例就是**实际要执行的任务**。`DynamicConfigScheduler` 会调度并执行这个任务实例。

### 五、`@WaitForRunners`：确保启动顺序

在应用启动时，Spring IOC 容器会立即开始创建和调度 Bean。这可能导致一些需要依赖启动阶段 `Runner` 任务（如：数据初始化）的任务，在 `Runner` 还没执行完时就被触发，从而引发冲突。

例如，一个负责实时获取在线节点数据的任务，如果比负责将所有节点设置为离线的 `Runner` 先执行，就可能造成数据混乱。

为了解决这个**竞态条件**，我们引入了 `@WaitForRunners` 注解。它的实现原理是：

* **切面拦截**：该注解通过AOP实现。当一个被 `@WaitForRunners` 注解标记的方法被调用时，切面会首先拦截它。
* **全局标志**：在 `Runner` 任务执行完毕后，一个全局的、线程安全的标志会被设置为“已完成”。
* **条件执行**：切面会检查这个标志。如果标志为“未完成”，则会跳过本次任务执行；如果标志为“已完成”，则继续执行任务。

通过这种方式，我们可以确保所有被 `@WaitForRunners` 标记的任务，都会在所有的 `Runner` 任务执行完毕之后，才开始它们真正开始执行

最后，需要明确的一点是，调度器是会在IoC实例化后马上开始调度任务，但任务是否执行是受注解控制的，因此`@WaitForRunners`应当作用于`ScheduledTaskToRun.execute()`方法上。